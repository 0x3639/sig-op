# OP-002: Nostr-Based Network Coordination for Testnet & Sidechain Deployment

**Status:** In progress

## Overview

Develop and deploy a trustless, Nostr-based coordination system that enables decentralized management of validator operations across testnets and sidechains. The system uses multi-signature quorum voting to coordinate network-wide actions such as upgrades, reboots, and genesis deployments without requiring centralized command-and-control infrastructure.

This initiative encompasses two core components:
- **qube-manager**: A Go client that runs on each Pillar as a service to receive, validate, and execute coordinated actions
- **qubestr**: A specialized Nostr relay that manages custom event types for infrastructure coordination

## Goals

1. **Production-Ready Coordination Infrastructure**
   - Complete feature development for qube-manager and qubestr with error handling and edge case coverage
   - Implement comprehensive testing (unit, integration, and end-to-end tests) with >80% code coverage
   - Add monitoring and observability (metrics collection, logging, alerting) for both relay and client components
   - Create comprehensive documentation including deployment guides, API specifications, and troubleshooting runbooks

2. **Automated Testnet Deployment**
   - Create workflows for spinning up new testnets with coordinated genesis deployment
   - Enable synchronized network launches across distributed validators
   - Support multiple concurrent testnet environments

3. **Trustless Multi-Signature Governance**
   - Enable quorum-based decision-making without central authority
   - Provide cryptographically verifiable command chains
   - Create transparent, auditable governance processes

## Technical Architecture

### Nostr Event-Based Coordination

The system leverages custom Nostr event kinds for validator coordination:

**Kind 33321 (HyperSignal)**: Action directives published by authorized HC1 developers
- Tags specify action type (upgrade/reboot), version, hash, network, and genesis URL
- Only authorized pubkeys can publish HyperSignal events (enforced at relay level)
- Addressable events ensure latest directive is always current

**Kind 3333 (QubeManager)**: Action acknowledgements published by validator nodes
- Reports execution status (success/failure) with timestamps
- Links back to originating HyperSignal event for auditability
- Creates complete execution trail across validator fleet

### Multi-Signature Verification

Validators independently:
1. Subscribe to HyperSignal events from authorized HC1 developer pubkeys
2. Aggregate votes across multiple developers for each proposed action
3. Verify quorum threshold is met (configurable, e.g., 3-of-5)
4. Execute approved actions only when consensus is reached
5. Publish acknowledgement events to create auditable trail

### Key Components

**qube-manager** (https://github.com/hypercore-one/qube-manager):
- Multi-relay subscription manager
- Cryptographic signature verification
- Quorum-based decision engine
- Idempotent action execution with history tracking
- Parallel relay publishing for fault tolerance

**qubestr** (https://github.com/coinselor/qubestr):
- Custom Nostr relay built on Khatru framework
- NIP-42 authentication enforcement
- Authorization via pubkey whitelist
- PostgreSQL event persistence
- Strict event validation

## Main Deliverables

### 1. Core System Hardening

**Testing & Quality Assurance:**
- Integration testing between qube-manager and qubestr
- Multi-node coordination testing with various quorum configurations
- Failure scenario testing (network partitions, relay failures, etc.)

**Monitoring & Observability:**
- Metrics collection for event processing and action execution
- Fleet-wide status dashboard showing validator coordination state
- Alerting for failed actions or quorum failures
- Event history queries and reporting tools
- Performance monitoring for relay and client components

**Documentation:**
- Technical architecture documentation
- API specifications for custom Nostr event kinds
- Security model and threat analysis
- Deployment guides for both components

### 2. Testnet Deployment Workflows

**Orchestration Tooling:**
- Automated genesis file generation and distribution
- Coordinated network launch scripts using reboot actions
- Multi-testnet management (parallel testnets with different configs)
- Validator onboarding automation
- Network health verification post-deployment

**Genesis Coordination:**
- Reboot action workflows with genesis URL distribution
- Deadline-based synchronized network launches
- Genesis parameter templates for common testnet scenarios
- Rollback procedures for failed deployments

**Deployment Runbooks:**
- Step-by-step testnet launch procedures
- Sidechain deployment guides
- Emergency procedures for network coordination failures
- Validator setup and configuration guides

### 3. Multi-Signature Coordination Workflows

**Upgrade Coordination:**
- Binary hash verification implementation
- Version comparison and upgrade path validation
- Rollback capabilities on upgrade failures
- Staged rollout support (partial fleet upgrades)

**Governance Documentation:**
- Quorum configuration best practices
- Developer key management procedures
- Authorization policy documentation
- Incident response procedures

**Operator Tools:**
- CLI tools for monitoring fleet status
- Event query utilities for audit trails
- Validator acknowledgement tracking
- Action history analysis tools

### 4. Production Deployment

**Infrastructure Setup:**
- Production relay deployment with redundancy
- PostgreSQL clustering for event persistence
- TLS/SSL configuration for secure WebSocket connections
- Backup and disaster recovery procedures

**Validator Integration:**
- qube-manager deployment automation
- Configuration management for multi-network support
- Key generation and secure storage
- Integration with existing validator infrastructure

## Timeline & Phases

### Phase 1: Core System Completion (Current)
- Complete qube-manager Kind 33321/3333 event support
- Production-harden qubestr relay
- Implement monitoring and metrics collection
- Complete integration testing

### Phase 2: Testnet Automation
- Build genesis deployment workflows
- Document deployment procedures

### Phase 3: Production Deployment & HC1 Internal Testing
- Deploy production relay infrastructure (qubestr) with redundancy and monitoring
- Deploy qube-manager as a service on HC1 HQZ Pillars
- Configure authorization with HC1 developer pubkeys
- Conduct internal testing with HC1 team:
  - Test upgrade coordination workflows
  - Test reboot/genesis deployment coordination
  - Validate multi-signature quorum functionality
  - Verify monitoring and alerting systems
- Refine operational procedures based on HC1 testing feedback

### Phase 4: Controlled External Rollout
- Publish comprehensive operator documentation and setup guides
- Open beta testing to select group of external Pillar operators
- Provide onboarding support and technical assistance
- Monitor coordination performance across diverse validator setups
- Gather feedback on usability and operational challenges
- Iterate on documentation and tooling based on external feedback
- Establish community governance procedures

### Phase 5: General Availability & Ecosystem Expansion
- Announce general availability to all Pillar operators
- Scale relay infrastructure to support growing validator set
- Support multiple concurrent testnets and sidechains
- Implement advanced features (staged rollouts, conditional actions, etc.)
- Continuous monitoring, optimization, and incident response

## Dependencies

- **go-zenon**: Core Zenon implementation for validator nodes
- **Nostr ecosystem**: NIP specifications and go-nostr library
- **PostgreSQL**: Event persistence for relay
- **Docker**: Containerized deployment infrastructure

## Related Repositories

- [`hypercore-one/qube-manager`](https://github.com/hypercore-one/qube-manager)
- [`coinselor/qubestr`](https://github.com/coinselor/qubestr/)
- [`zenon-network/go-zenon`](https://github.com/zenon-network/go-zenon)
